# 内容
这一节了解一下 golang 中的 rpc 和 threads

## 为什么使用 go 来教学？
- go 中有 goroutine，更容易使用的并发机制
- 更加方便使用的 RPC
- 类型安全
- 提供 GC 机制
- golang 简单易用

## golang 中的 goroutine（自行了解）
并发对分布式编程是十分重要的，并且 go 的 goroutine 是十分简单易用的。
稍微了解 go 的都知道其实 goroutine 是建立在系统线程上的一种机制，更加轻便，快速切换。

## 使用 thread 的原因
I/O 并发：客户端发送多个请求给不同的服务器然后等待回复，服务器接收多个客户端的请求进行处理。等待磁盘读取的同时处理客户的请求。
多核性能：可以充分地利用多核的性能
方便一些实现：例如 master 循环的检查每个 worker 状态是否正常。

## thread 的替代方案：
在一个线程中使用事件循环机制，将所有事件存储起来，并不断地获取触发的事件并进行处理。redis 中有类似的操作。

## 使用 thread 的挑战：
- 共享内存带来的冲突，可以加锁，或者使用 TLS
- thread 之间的同步。golang 中推荐 channel 来进行同步，go 还提供了许多同步方式，sync 包中
- 死锁

## 爬虫示例
课程后半段通过一个爬虫例子来分别展示了三种不同的方式实现了 Crawler。
- 递归的进行爬取
- 通过 goroutine + WaitGroup 的方式并发的实现 Crawler，并通过 Mutex + map 的方式防止爬取重复的 URL
- 通过 channel 实现不同 goroutine 之间的同步，并使用 map 来防止重复的爬取，因为该 map 上的操作不涉及并发。

# 总结一下
除了课程中的 Crawler，schedule 中还提供了一个 kv 例子使用了 RPC 机制，课上时间不够就没讲。这节课就讲了一下 goroutine 中的协程以及并发控制，同步方法。其中 Crawler 中实现的三种方式可以看一下，实现的很有特点。
简单介绍一下 KV 例子：
1. 启动服务端
2. 创建客户端，并和服务端建立 TCP 连接，然后调用 rpc 接口，底层通过 RPC 库的 Call 实现。
3. 服务器处理收到的请求，执行后返回即可，服务器使用 goroutine 执行每个新的连接上的调用，所以需要做一些 mutex 的操作。

但是使用 RPC 需要考虑很多的网络延迟、执行失败等等问题。真正在项目中使用 RPC 需要考虑的方方面面东西繁琐。不过面对一般的错误。可以最简单的设置超时，失败后客户端业务层进行处理，判断是重新执行，还是报错返回等等。
